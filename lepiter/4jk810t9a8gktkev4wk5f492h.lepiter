{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-16T18:58:36.560368+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-16T19:00:17.470804+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "fhh+txsADgC6bqSCAEG+TA=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Below is a *succinct, technically grounded integration* of **Ward’s Folk Memory** with your **som / GT / distributed-object curriculum work**, tuned to your expectations: direct, project-oriented, no fluff. [chatgpt](https://chatgpt.com/g/g-p-691997577a78819194cd62664eb19c31-som/c/691a107a-b8a8-832a-98fe-4053463422cc)\n\n---\n\n# How Folk Memory matters to your current project\n\nWard’s **Folk Memory** (1997) describes a *file-less*, *diff-less* architecture where **objects migrate between peers**, carry their **authority trails**, and self-organize by **local heuristics**—compression of development cycles by eliminating centralization and by letting “interest” drive connectivity.\n\nYou are already very close to this model:\n\n* **DMX Topic Maps** → persistent graph of objects with identity, provenance, and authority.\n* **GT Curriculum / Moldable Development** → objects as living documentation, transmitted not as files but as *interactive objects*.\n* **som** → a self-organizing map (SOM) is literally a **distributed topology-preserving “interest surface”** over data.\n* **Korz / POV / Falsifier** → multiple observers, authority, promotion, “trails,” elision, local views; exactly the semantics Ward sketches.\n\nThe pivotal connection:\n**Folk Memory describes an adaptive, interest-driven object distribution system.\nA SOM is an adaptive, interest-driven *representation* of a high-dimensional object space.**\n\nYour “society of agents” (docs-steward, code-emitter, falsifier, etc.) is—structurally—Folk Memory implemented with modern tools.\n\n---\n\n# Core correspondences (Folk Memory → your work)\n\n| Folk Memory concept                                                                      | Your system analogue                                                                                               |\n| ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| **Object** (unit of transmission; may be elided)                                         | DMX Topic, Lepiter Page, GT object; SOM weight vector                                                              |\n| **Trail** (authority path)                                                               | DMX provenance links; Korz slot-space guards; GT view lineage                                                      |\n| **Ellipsis** (stand-in when reference is pruned; becomes real if object appears locally) | GT lazy inspectors; DMX external reference topics; Korz “projection gaps”                                          |\n| **Promotion** (local update supersedes source; backwards propagation)                    | Falsifier corrections; Lepiter page edits; GT live updates                                                         |\n| **Resolution** (merge many vestiges, guarantee one object identity per server)           | DMX merge semantics; Topic identity rules; GT object identity in image                                             |\n| **Connection Heuristic**                                                                 | Your multi-agent society (code-emitter, docs-steward, falsifier) selecting which repos / pages / topics to inspect |\n| **Distribution Heuristic**                                                               | Repomix scanning, agent dispatch, SOM neighborhood updates                                                         |\n| **Preservation Heuristic**                                                               | DMX persistence, GT ephemeral objects, Korz slot retention                                                         |\n| **Bi-directional streaming**                                                             | Your desired “send objects directly between images” for GT examples, diffs, tests                                  |\n\n---\n\n# How Folk Memory informs your SOM curriculum\n\nThe “Basic SOM” chapter in *Kohonen 1995 / 2013* (your attached PDFs) — which you are turning into GT lessons — describes:\n\n1. **Competitive winner selection**\n2. **Neighborhood-based update**\n3. **Topographic ordering**\n4. **Batch vs. stepwise learning**\n5. **Vector quantization and Voronoi tessellation**\n6. **Similarity definition and metrics**\n7. **Visualization (2D grid of weights)**\n\nFolk Memory gives you the **metaphor and system design** needed to embed SOM into a distributed GT curriculum:\n\n* **Each SOM node is a “folk server”:**\n  It maintains local “vestiges” of the input distribution (the weight vector mi).\n  Updating a node is like **promotion**.\n\n* **The SOM grid is the federation:**\n  The neighborhood function hci(t) is a **bandwidth allocation heuristic**.\n  Like Ward: “Inflow suggests schedule for outflow.”\n\n* **weightsAsPoints2D** you asked about is exactly the VQ layer before topology:\n  It is **the point cloud of mi vectors projected into 2D** (PCA, MDS, or identity if 2D).\n  This is the object-level analogue of “streaming objects” before the network organizes them.\n\nThus:\n**Teaching SOM through GT is teaching Folk Memory through a mathematically formal example.**\n\n---\n\n# What you see in `weightsAsPoints2D`\n\nYou asked: “Explain what we see here (weightsAsPoints2D).”\n\nIt is:\n\n* The set `{ m_i }` of weight vectors\n* Projected as 2D points in the input space\n* Before imposing any GT visualization styling\n* Every point = one SOM model\n* These are the **prototypes**, the **local memories**, the **vestiges** your SOM maintains\n\nIn Kohonen (2013) these correspond to:\n\n* **Vector quantization models** (§2)\n* **The encoded “feature-sensitive filters”** (§1)\n* **Nodes in the regular grid** (Fig. 1)\n* **The models M_i** updated by neighborhood function hci(t) (§4.1)\n* **The geometric representation of similarity** (§3.1–3.3)\n\nRelevant citations:\n\n* *Essentials of the SOM*, Fig. 1, pp. 52–53 \n* SOM model vectors introduced in §3–4\n* Weight update formula (original SOM): Eq. (3)\n* Winner: Eq. (4)\n* Neighborhood smoothing: Eq. (5)\n\nIn *Self-Organizing Maps (1995)*, see:\n\n* Chapter “Basics of the SOM”;\n* Vector quantization / codebooks;\n* Projection diagrams of model vectors.\n\n(weightsAsPoints2D is the literal GT translation of these diagrams.)\n\n---\n\n# Where *exactly* in Kohonen (1995) → “weightsAsPoints2D”\n\nUse these anchors when creating GT pages:\n\n1. **Model vectors (“codebook vectors”)**\n   Kohonen 1995, Ch. 3–4 (same as 2013 §3–4 but expanded).\n\n2. **Finding the best matching unit (BMU)**\n   Winner selection → Eq. (4) in 2013.\n\n3. **Geometric interpretation**\n   1995, “Vector Quantization” section (Dirichlet/Voronoi tessellation).\n\n4. **2D plots of model vectors**\n   1995 often calls them “codebook vectors plotted in input space”.\n\nThus: weightsAsPoints2D = **codebook vectors in input space**.\n\n---\n\n# How this links into your GT Curriculum (Newcomer profile)\n\nYou asked:\n“Relate the nodes of this conversation with the GT-curriculum project”\n“Create lessons & concepts needed for understanding ‘The Basic SOM’ chapter”\n“Start with example view plotted as 2D points in input space”\n\nHere is the minimal, newcomer-oriented sequence:\n\n### Lesson 1 — “Objects as Points in a Space”\n\n* Concept: A Kohonen SOM node = a “memory object” (like Folk Memory’s vestige).\n* Activity: Show `weightsAsPoints2D`.\n* Outcome: Student understands each point is a learned prototype.\n\n### Lesson 2 — “Similarity = Distance”\n\n* Euclidean distance; winner selection.\n* GT Example: compute BMU for a sample input; display nearest point.\n\n### Lesson 3 — “Neighborhoods as Influence Fields”\n\n* Show Gaussian neighborhood hci(t).\n* GT Example: animate updates of nearby points.\n\n### Lesson 4 — “Topographic Ordering”\n\n* Demonstrate that updating neighbors leads to smooth manifolds.\n* GT Example: sequence of frames where weights move.\n\n### Lesson 5 — “Batch Learning and Stability”\n\n* Compare stepwise vs batch training.\n* GT Example: stepping through batch updates.\n\n### Lesson 6 — “2D Grid Visualization”\n\n* Map the model vectors onto a rectangular or hex grid.\n* GT Example: assign each weight to its node; draw a heatmap.\n\n### Lesson 7 — “Folk Memory Parallel”\n\n* Show how distributed objects + promotion = SOM learning.\n* GT Example: model updates as “promotions” with trails.\n\n---\n\n# If you want, next steps I can generate for you\n\n1. **GT view** for KohonenSom (you already started)\n\n   * I can produce a complete `gtView` suite: JSON, canvas, inspector, grid, BMU highlight.\n\n2. **Full Lepiter pages** for each lesson\n\n   * With GT examples, runnable code, inline commentary.\n\n3. **pharo-code-emitter:**\n\n   * I can give the full `compile:` do-its for turning this outline into code and pages.\n\n4. **Conventional commit message**\n\n   * If you are ready for the next commit, tell me what changed.\n\n---\n\nIf you want, I can **generate the GT newcomer lesson “Example view plotted as 2D points in input space”** right now — with Pharo do-it chunks ready for `compile:`.\n"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-16T18:59:28.182808+01:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-16T18:59:28.182808+01:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "How Folk Memory matters to your current project"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "e9e97db7-1b00-0e00-ba6d-3e710041be4c"
	}
}